<!DOCTYPE html>

<html>
<head>
  <title>Patches.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="AgentSet.html">
                  AgentSet.js
                </a>
              
                
                <a class="source" href="Animator.html">
                  Animator.js
                </a>
              
                
                <a class="source" href="Color.html">
                  Color.js
                </a>
              
                
                <a class="source" href="ColorMap.html">
                  ColorMap.js
                </a>
              
                
                <a class="source" href="DataSet.html">
                  DataSet.js
                </a>
              
                
                <a class="source" href="Model.html">
                  Model.js
                </a>
              
                
                <a class="source" href="Mouse.html">
                  Mouse.js
                </a>
              
                
                <a class="source" href="OofA.html">
                  OofA.js
                </a>
              
                
                <a class="source" href="Patch.html">
                  Patch.js
                </a>
              
                
                <a class="source" href="Patches.html">
                  Patches.js
                </a>
              
                
                <a class="source" href="RGBDataSet.html">
                  RGBDataSet.js
                </a>
              
                
                <a class="source" href="TileDataSet.html">
                  TileDataSet.js
                </a>
              
                
                <a class="source" href="util.html">
                  util.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>Patches.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">import</span> util <span class="hljs-keyword">from</span> <span class="hljs-string">'./util.js'</span>
<span class="hljs-keyword">import</span> AgentSet <span class="hljs-keyword">from</span> <span class="hljs-string">'./AgentSet.js'</span>
<span class="hljs-keyword">import</span> DataSet <span class="hljs-keyword">from</span> <span class="hljs-string">'./DataSet.js'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Patches are the world other agentsets live on. They create a coord system
from Model’s world values: size, minX, maxX, minY, maxY</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Patches</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AgentSet</span> </span>{
  <span class="hljs-keyword">constructor</span> (model, agentProto, name, baseSet = null) {
    <span class="hljs-keyword">super</span>(model, agentProto, name, baseSet)</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Skip if an basic Array ctor or a breedSet. See AgentSet comments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> model === <span class="hljs-string">'number'</span> || <span class="hljs-keyword">this</span>.isBreedSet()) <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">this</span>.world = model.world
    <span class="hljs-keyword">this</span>.populate()
    <span class="hljs-keyword">this</span>.setPixels()
    <span class="hljs-keyword">this</span>.labels = [] <span class="hljs-comment">// sparse array for labels</span>
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Set up all the patches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  populate () {
    util.repeat(<span class="hljs-keyword">this</span>.world.numX * <span class="hljs-keyword">this</span>.world.numY, (i) =&gt; {
      <span class="hljs-keyword">this</span>.add(<span class="hljs-built_in">Object</span>.create(<span class="hljs-keyword">this</span>.agentProto))
    })
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Setup pixels used for patch.color: <code>draw</code> and <code>importColors</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  setPixels () {
    <span class="hljs-keyword">const</span> {patchSize, numX, numY} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>.model.contexts.patches
    <span class="hljs-keyword">const</span> pixels = <span class="hljs-keyword">this</span>.pixels = {are1x1: patchSize === <span class="hljs-number">1</span>}
    pixels.ctx = pixels.are1x1 ? ctx : util.createCtx(numX, numY)
    <span class="hljs-keyword">this</span>.setImageData()
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Create the pixels object used by <code>setPixels</code> and <code>installColors</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  setImageData () {
    <span class="hljs-keyword">const</span> pixels = <span class="hljs-keyword">this</span>.pixels
    pixels.imageData = util.ctxImageData(pixels.ctx)
    pixels.data8 = pixels.imageData.data
    pixels.data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(pixels.data8.buffer)
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Return the offsets from a patch for its 8 element neighbors.
Specialized to be faster than patchRect below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  neighborsOffsets (x, y) {
    <span class="hljs-keyword">const</span> {minX, maxX, minY, maxY, numX} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">if</span> (x === minX) {
      <span class="hljs-keyword">if</span> (y === minY) <span class="hljs-keyword">return</span> [-numX, -numX + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
      <span class="hljs-keyword">if</span> (y === maxY) <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, numX + <span class="hljs-number">1</span>, numX]
      <span class="hljs-keyword">return</span> [-numX, -numX + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, numX + <span class="hljs-number">1</span>, numX]
    }
    <span class="hljs-keyword">if</span> (x === maxX) {
      <span class="hljs-keyword">if</span> (y === minY) <span class="hljs-keyword">return</span> [-numX - <span class="hljs-number">1</span>, -numX, <span class="hljs-number">-1</span>]
      <span class="hljs-keyword">if</span> (y === maxY) <span class="hljs-keyword">return</span> [numX, numX - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>]
      <span class="hljs-keyword">return</span> [-numX - <span class="hljs-number">1</span>, -numX, numX, numX - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>]
    }
    <span class="hljs-keyword">if</span> (y === minY) <span class="hljs-keyword">return</span> [-numX - <span class="hljs-number">1</span>, -numX, -numX + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>]
    <span class="hljs-keyword">if</span> (y === maxY) <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>, numX + <span class="hljs-number">1</span>, numX, numX - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>]
    <span class="hljs-keyword">return</span> [-numX - <span class="hljs-number">1</span>, -numX, -numX + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, numX + <span class="hljs-number">1</span>, numX, numX - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>]
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Return the offsets from a patch for its 4 element neighbors (N,S,E,W)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  nighbors4Offsets (x, y) {
    <span class="hljs-keyword">const</span> numX = <span class="hljs-keyword">this</span>.world.numX
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.neighborsOffsets(x, y)
      .filter(n =&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, numX, -numX].indexOf(n) &gt;= <span class="hljs-number">0</span>)
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Return my 8 patch neighbors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  neighbors (patch) {
    <span class="hljs-keyword">const</span> {id, x, y} = patch
    <span class="hljs-keyword">const</span> offsets = <span class="hljs-keyword">this</span>.neighborsOffsets(x, y)
    offsets.forEach((o, i, a) =&gt; { a[i] = <span class="hljs-keyword">this</span>[o + id] })
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.asAgentSet(offsets)
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Return my 4 patch neighbors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  neighbors4 (patch) {
    <span class="hljs-keyword">const</span> {id, x, y} = patch
    <span class="hljs-keyword">const</span> offsets = <span class="hljs-keyword">this</span>.nighbors4Offsets(x, y)
    offsets.forEach((o, i, a) =&gt; { a[i] = <span class="hljs-keyword">this</span>[o + id] })
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.asAgentSet(offsets)
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Patches in rectangle dx, dy from p, dx, dy integers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  patchesInRect (p, dx, dy = dx, meToo = <span class="hljs-literal">true</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Return cached rect if one exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (p.pRect &amp;&amp; p.pRect.length === dx * dy) <span class="hljs-keyword">return</span> p.pRect
    <span class="hljs-keyword">const</span> rect = []
    <span class="hljs-keyword">const</span> {minX, maxX, minY, maxY} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">const</span> [xmin, xmax] = [<span class="hljs-built_in">Math</span>.max(minX, p.x - dx), <span class="hljs-built_in">Math</span>.min(maxX, p.x + dx)]
    <span class="hljs-keyword">const</span> [ymin, ymax] = [<span class="hljs-built_in">Math</span>.max(minY, p.y - dy), <span class="hljs-built_in">Math</span>.min(maxY, p.y + dy)]
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> y = ymin; y &lt;= ymax; y++)
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x = xmin; x &lt;= xmax; x++) {
        <span class="hljs-keyword">const</span> pnext = <span class="hljs-keyword">this</span>.patchXY(x, y)
        <span class="hljs-keyword">if</span> (meToo || p !== pnext) rect.push(pnext)
      }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.asAgentSet(rect)
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Patches in circle r from p, r integer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  patchesInRadius (p, radius, meToo = <span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">const</span> rect = <span class="hljs-keyword">this</span>.patchesInRect(p, radius, radius, meToo)
    <span class="hljs-keyword">const</span> rSq = radius * radius
    <span class="hljs-keyword">const</span> distSq = (p1) =&gt; util.distanceSq(p1.x, p1.y, p.x, p.y)
    <span class="hljs-keyword">return</span> rect.filter(p1 =&gt; distSq(p1) &lt;= rSq) <span class="hljs-comment">// REMIND: perf vs forEach?</span>
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Draw the patches onto the ctx using the pixel image data colors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  draw (ctx = <span class="hljs-keyword">this</span>.model.contexts.patches) {
    <span class="hljs-keyword">const</span> {pixels} = <span class="hljs-keyword">this</span>
    pixels.ctx.putImageData(pixels.imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> (pixels.are1x1) <span class="hljs-keyword">return</span>
    util.fillCtxWithImage(ctx, pixels.ctx.canvas)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.labels) { <span class="hljs-comment">// `for .. in`: skips sparse array gaps.</span>
      <span class="hljs-keyword">const</span> label = <span class="hljs-keyword">this</span>.labels[i]
      <span class="hljs-keyword">const</span> {labelOffset: offset, labelColor: color} = <span class="hljs-keyword">this</span>[i]
      <span class="hljs-keyword">const</span> [x, y] = <span class="hljs-keyword">this</span>.patchXYToPixelXY(...this.patchIndexToXY(i))
      util.ctxDrawText(ctx, label, x + offset[<span class="hljs-number">0</span>], y + offset[<span class="hljs-number">1</span>], color.getCss())
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Draws, or “imports” an image URL into the drawing layer.
The image is scaled to fit the drawing layer.
This is an async function, using es6 Promises.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  importDrawing (imageSrc) {
    util.imagePromise(imageSrc)
    .then(img =&gt; <span class="hljs-keyword">this</span>.installDrawing(img))
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Direct install image into the given context, not async.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  installDrawing (img, ctx = <span class="hljs-keyword">this</span>.model.contexts.drawing) {
    util.fillCtxWithImage(ctx, img)
  }
  importColors (imageSrc) {
    util.imagePromise(imageSrc)
    .then(img =&gt; <span class="hljs-keyword">this</span>.installColors(img))
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Direct install image into the patch colors, not async.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  installColors (img) {
    util.fillCtxWithImage(<span class="hljs-keyword">this</span>.pixels.ctx, img)
    <span class="hljs-keyword">this</span>.setImageData()
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Import/export DataSet to/from patch variable <code>patchVar</code>.
<code>useNearest</code>: true for fast rounding to nearest; false for bi-linear.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  importDataSet (dataSet, patchVar, useNearest = <span class="hljs-literal">false</span>) {
    <span class="hljs-keyword">const</span> {numX, numY} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">const</span> dataset = dataSet.resample(numX, numY, useNearest)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> patch <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>)
      patch[patchVar] = dataset.data[patch.id]
  }
  exportDataSet (patchVar) {
    <span class="hljs-keyword">const</span> {numX, numY} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">const</span> data = util.aProps(<span class="hljs-keyword">this</span>, patchVar)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSet(numX, numY, data)
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Return true if x,y floats are within patch world.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  isOnWorld (x, y) {
    <span class="hljs-keyword">const</span> {minXcor, maxXcor, minYcor, maxYcor} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">return</span> (minXcor &lt;= x) &amp;&amp; (x &lt;= maxXcor) &amp;&amp; (minYcor &lt;= y) &amp;&amp; (y &lt;= maxYcor)
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Return patch at x,y float values according to topology.
Return undefined if off-world</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  patch (x, y) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isOnWorld) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.patchXY(<span class="hljs-built_in">Math</span>.round(x), <span class="hljs-built_in">Math</span>.round(y))
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Return the patch id/index given valid integer x,y in patch coords</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  patchXYToIndex (x, y) {
    <span class="hljs-keyword">const</span> {minX, maxY, numX} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">return</span> (x - minX) + (numX * (maxY - y))
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Return the patch x,y patch coords given a valid patches id/index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  patchIndexToXY (ix) {
    <span class="hljs-keyword">const</span> {minX, maxY, numX} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">return</span> [(ix % numX) + minX, maxY - <span class="hljs-built_in">Math</span>.floor(ix / numX)]
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Return the patch at x,y where both are valid integer patch coordinates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  patchXY (x, y) { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-keyword">this</span>.patchXYToIndex(x, y)] }</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Convert to/from pixel coords &amp; patch coords</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  pixelXYToPatchXY (x, y) {
    <span class="hljs-keyword">const</span> {patchSize, minXcor, maxYcor} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">return</span> [minXcor + (x / patchSize), maxYcor - (y / patchSize)]
  }
  patchXYToPixelXY (x, y) {
    <span class="hljs-keyword">const</span> {patchSize, minXcor, maxYcor} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">return</span> [(x - minXcor) * patchSize, (maxYcor - y) * patchSize]
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Return a random valid float x,y point in patch space</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  randomPt () {
    <span class="hljs-keyword">const</span> {minXcor, maxXcor, minYcor, maxYcor} = <span class="hljs-keyword">this</span>.world
    <span class="hljs-keyword">return</span> [util.randomFloat2(minXcor, maxXcor),
            util.randomFloat2(minYcor, maxYcor)]
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Return a random patch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  randomPatch () { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.oneOf() }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Get/Set label.
Set removes label if label is null or undefined.
Get returns undefined if no label.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  setLabel (patch, label) {
    <span class="hljs-keyword">if</span> (label == <span class="hljs-literal">null</span>) <span class="hljs-comment">// null or undefined</span>
      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.labels[patch.id]
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">this</span>.labels[patch.id] = label
  }
  getLabel (patch) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.labels[patch.id]
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Diffuse the value of patch variable <code>p.v</code> by distributing <code>rate</code> percent
of each patch’s value of <code>v</code> to its neighbors.
If a color map is given, scale the patch color via variable’s value
If the patch has less than 4/8 neighbors, return the extra to the patch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  diffuse (v, rate, colorMap = <span class="hljs-literal">null</span>, min = <span class="hljs-number">0</span>, max = <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">this</span>.diffuseN(<span class="hljs-number">8</span>, v, rate, colorMap, min, max)
  }
  diffuse4 (v, rate, colorMap = <span class="hljs-literal">null</span>, min = <span class="hljs-number">0</span>, max = <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">this</span>.diffuseN(<span class="hljs-number">4</span>, v, rate, colorMap, min, max)
  }
  diffuseN (n, v, rate, colorMap = <span class="hljs-literal">null</span>, min = <span class="hljs-number">0</span>, max = <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (n !== <span class="hljs-number">4</span> &amp;&amp; n !== <span class="hljs-number">8</span>) util.error(<span class="hljs-string">'diffuseN n != 4 or 8'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>zero temp variable if not yet set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>]._diffuseNext === <span class="hljs-literal">undefined</span>)
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>) p._diffuseNext = <span class="hljs-number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>pass 1: calculate contribution of all patches to themselves and neighbors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>) {
      <span class="hljs-keyword">const</span> dv = p[v] * rate
      <span class="hljs-keyword">const</span> dvn = dv / n
      <span class="hljs-keyword">const</span> neighbors = n === <span class="hljs-number">8</span> ? p.neighbors : p.neighbors4
      <span class="hljs-keyword">const</span> nn = neighbors.length
      p._diffuseNext += p[v] - dv + (n - nn) * dvn
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> n <span class="hljs-keyword">of</span> neighbors) n._diffuseNext += dvn
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>pass 2: set new value for all patches, zero temp,
modify color if colorMap given</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> p <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>) {
      p[v] = p._diffuseNext
      p._diffuseNext = <span class="hljs-number">0</span>
      <span class="hljs-keyword">if</span> (colorMap)
        p.setColor(colorMap.scaleColor(p[v], min, max))
    }
  }

}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Patches</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
